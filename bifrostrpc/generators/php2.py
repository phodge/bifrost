from pathlib import Path
from typing import Any, Callable, List, Optional, Tuple, Type, Union

import dataclasses
from paradox.expressions import (PanCall, PanExpr, PanIndexAccess,
                                 PanKeyAccess, PanVar, and_, isbool, isint,
                                 islist, isnull, isstr, not_, pan, phpexpr)
from paradox.generate.files import FilePHP
from paradox.generate.statements import (ClassSpec, ConditionalBlock,
                                         DictBuilderStatement, FunctionSpec,
                                         Statement, Statements)
from paradox.typing import (CrossAny, CrossCallable, CrossNewType, dictof,
                            unionof)
from typing_extensions import Literal

from bifrostrpc import Flavour
from bifrostrpc.generators import Names
from bifrostrpc.generators.common import getFailureModeClasses
from bifrostrpc.typing import (Advanced, DataclassTypeSpec, DictTypeSpec,
                               FuncSpec, ListTypeSpec, LiteralTypeSpec,
                               NullTypeSpec, ScalarTypeSpec, TypeSpec,
                               UnionTypeSpec, _generateCrossType, getTypeSpec)

#try:
#    from typing import Literal  # type: ignore
#except ImportError:
#    from typing_extensions import Literal


# TODO: replace all TypeError with InvalidArgumentException?


HEADER = 'generated by Bifrost RPC'


class _FilterNotPossible(Exception):
    pass


def generateClient(
    rootpath: Path,
    *,
    classname: str,
    namespace: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    adv: Advanced,
    flavour: Literal["abstract"],
) -> None:
    nspath = rootpath.joinpath(namespace.replace("\\", "/"))

    # start with the main file itself
    dest = FilePHP(
        target=nspath / f"{classname}.php",
        namespace=namespace,
    )

    dest.filecomment(HEADER)

    # TODO: we need to write out failure mode classes
    for errname, classspec in getFailureModeClasses():
        #errdest = FilePHP(
            #target=nspath / f"{errname}.php",
            #namespace=namespace,
        #)
        #errdest.contents.also(classspec)
        dest.contents.also(classspec)

    # write out each of our dataclasses
    for dc in adv.getAllDataclasses():
        dcspec = _getDataclassSpec(dc, adv)
        dest.contents.also(dcspec)

    # generate function wrappers
    dest.contents.also(_generateWrappers(classname, funcspecs, adv, flavour))

    dest.writefile()
    dest.makepretty()


def _generateWrappers(
    classname: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    adv: Advanced,
    flavour: Flavour,
) -> ClassSpec:
    cls = ClassSpec(
        classname,
        isabstract=flavour == 'abstract',
        # TODO: we really should have a docstring for this
    )

    # add an dispatch() function that is used for all methods
    dispatchfn = cls.createMethod(
        'dispatch',
        unionof(CrossNewType('ApiFailure'), CrossAny()),
        isabstract=flavour == 'abstract',
        phpprotected=True,
    )

    #def addimport(module: str) -> None:
        #cls.alsoImportPy(module)

    # the method that should be called
    dispatchfn.addPositionalArg('method', str)
    # a dict of params to pass to the method
    dispatchfn.addPositionalArg('params', dictof(str, CrossAny()))
    # converter will be called with the result of the method call.
    # It may modify result before returning it. It may raise a TypeError
    # if any part of result does not match the method's return type.
    dispatchfn.addPositionalArg('converter', CrossCallable([CrossAny()], CrossAny()))

    if flavour == 'requests':
        # TODO: finish this
        dispatchfn.alsoRaise(
            msg="TODO: perform the request using requests library"
        )
    else:
        assert flavour == 'abstract'
        # TODO: abstract function should get '...' body automatically?
        #dispatchfn.also('...')

    for name, funcspec in funcspecs:
        retspec = funcspec.getReturnSpec()

        # build a custom converter function for this method
        conv = FunctionSpec('_converter', CrossAny())
        v_result = conv.addPositionalArg('result', retspec.getCrossType())
        names = Names()

        try:
            filterblock = _getFilterBlock('result', '$DATA', retspec, names)
            conv.also(filterblock)
        except _FilterNotPossible:
            v_converted = names.getSpecificName('converted', True, retspec.getCrossType())
            conv.also(_getConverterBlock(
                v_result,
                v_converted,
                '$DATA',
                retspec,
                names,
                adv,
            ))
            conv.alsoReturn(v_converted)
        else:
            conv.alsoReturn(v_result)

        rettype = unionof(CrossNewType('ApiFailure'), _generateCrossType(retspec, adv))
        method = cls.createMethod(name, rettype)

        for argname, spec in funcspec.getArgSpecs().items():
            method.addPositionalArg(argname, _generateCrossType(spec, adv))

        v_args = PanVar('args', dictof(str, CrossAny()))
        argnames = DictBuilderStatement.fromPanVar(v_args)
        for n in funcspec.getArgSpecs().keys():
            # TODO: dataclasses aren't automatically JSON serializable, so we need to raise an
            # error if we try to generate a client that has a dataclass argument type
            argnames.addPair(n, False)
        method.also(argnames)

        method.blank()
        method.remark(
            'include [__dataclass__] in returned values so that we can rebuild dataclasses',
        )
        method.alsoAssign(v_args["__showdataclass__"], True)

        method.also(conv)

        method.alsoReturn(PanCall(
            'self._dispatch',
            pan(name),
            v_args,
            pan('_converter'),
        ))

    # TODO: rather than writing to the file pointer, we should really be returning the class
    return cls


def _getDataclassSpec(
    dc: Type[Any],
    adv: Advanced,
) -> ClassSpec:
    name = dc.__name__
    cls = ClassSpec(name, isdataclass=True)

    for field in dataclasses.fields(dc):
        fieldspec = getTypeSpec(field.type, adv)
        cls.addProperty(field.name, fieldspec.getCrossType(), initarg=True)

    # the dataclass needs a deserialization method, too
    fromarray = cls.createMethod('fromArray', CrossNewType(name, quoted=True), isstaticmethod=True)
    v_data = fromarray.addPositionalArg('data', CrossAny())
    fromarray.addPositionalArg('label', str)

    # constructor part 1 - ensure the provided data is a dict
    with fromarray.withCond(not_(islist(v_data))) as cond:
        cond.alsoRaise("InvalidArgumentException", expr=phpexpr('"$label must be an array"'))

    # constructor part 2 - ensure the __dataclass__ item is present
    with fromarray.withCond(phpexpr(f'($data["__dataclass__"] ?? null) != {name!r}')) as cond:
        cond.alsoRaise("InvalidArgumentException",
                       expr=phpexpr('"{$label}[\'__dataclass__\'] must be %s"' % repr(name)))

    names = Names()

    buildargs: List[PanExpr] = []

    # validate each property item
    for field in dataclasses.fields(dc):
        fname = field.name

        with fromarray.withCond(phpexpr(f'!array_key_exists({fname!r}, $data)')) as cond:
            cond.alsoRaise("InvalidArgumentException",
                           expr=phpexpr('"{$label}[%r] is missing"' % fname))

        # use a try/catch to assign the dict key to a local variable before we filter/convert it.
        # This allows us to trap the KeyError quickly and explicitly
        v_var = PanVar(names.getNewName('', fname, True), CrossAny())
        fromarray.alsoDeclare(v_var, None, phpexpr(f'$data[{fname!r}]'))
        fieldspec = getTypeSpec(field.type, adv)

        # check the local variable's type
        try:
            fromarray.also(_getFilterBlock(v_var, f'$data[{fname!r}]', fieldspec, names))
        except _FilterNotPossible:
            stmts = Statements()
            # TODO: what is the correct type here?
            v_copy = PanVar(names.getNewName(v_var, 'converted', True), CrossAny())
            stmts.also(_getConverterBlock(
                v_var,
                v_copy,
                f"$data[{fname!r}]", fieldspec, names, adv,
            ))
            stmts.alsoAssign(v_var, v_copy)
            fromarray.also(stmts)

        buildargs.append(v_var)

    fromarray.alsoReturn(PanCall(name, *buildargs))

    return cls


def _generateType(spec: TypeSpec, adv: Advanced, addimport: Callable[[str], None]) -> str:
    raise Exception("TODO: rewrite this")  # noqa
    if isinstance(spec, NullTypeSpec):
        return 'None'

    if isinstance(spec, ScalarTypeSpec):
        return spec.typeName

    if isinstance(spec, ListTypeSpec):
        itemtype = _generateType(spec.itemSpec, adv, addimport)
        return f'typing.List[{itemtype}]'

    if isinstance(spec, DictTypeSpec):
        keytype = _generateType(spec.keySpec, adv, addimport)
        valuetype = _generateType(spec.valueSpec, adv, addimport)
        return f'typing.Dict[{keytype}, {valuetype}]'

    if isinstance(spec, DataclassTypeSpec):
        if not adv.hasDataclass(spec.class_):
            raise Exception(
                f'Cannot generate a python type for unknown dataclass {spec.class_.__name__}')

        return spec.class_.__name__

    if isinstance(spec, UnionTypeSpec):
        joined = ", ".join([
            _generateType(variantspec, adv, addimport)
            for variantspec in spec.variants
        ])
        return f'typing.Union[{joined}]'

    if isinstance(spec, LiteralTypeSpec):
        if spec.expectedType is bool:
            raise Exception("TODO: test this code path")  # noqa
            addimport('typing_extensions')
            return f'typing_extensions.Literal[{spec.expected!r}]'

        if spec.expectedType is int:
            raise Exception("TODO: test this code path")  # noqa
            addimport('typing_extensions')
            return f'typing_extensions.Literal[{spec.expected}]'

        if spec.expectedType is not str:
            raise Exception(f"Unexpected literal type {spec.expectedType.__name__}")

        addimport('typing_extensions')
        return f'typing_extensions.Literal[{spec.expected!r}]'

    raise Exception(f"TODO: generate a type for {spec!r}")


def _getTypeNoMatchExpr(
    input: Union[PanVar, PanIndexAccess, PanKeyAccess],
    spec: TypeSpec,
) -> Optional[PanExpr]:
    if isinstance(spec, NullTypeSpec):
        return not_(isnull(input))

    if isinstance(spec, ScalarTypeSpec):
        if spec.scalarType is str:
            return not_(isstr(input))
        if spec.scalarType is int:
            return not_(isint(input))
        assert spec.scalarType is bool
        return not_(isbool(input))

    if isinstance(spec, LiteralTypeSpec):
        raise Exception(f"TODO: finish _getTypeNoMatchExpr() for {spec!r}")  # noqa
        if spec.expectedType is bool:
            return f'{var_or_prop} is not {spec.expected!r}'

        assert spec.expectedType in (int, str)
        what = spec.expectedType.__name__
        return f'not (isinstance({var_or_prop}, {what}) and {var_or_prop} == {spec.expected})'

    if isinstance(spec, DataclassTypeSpec):
        raise Exception(f"TODO: finish _getTypeNoMatchExpr() for {spec!r}")  # noqa
        # not possible
        return None

    if isinstance(spec, ListTypeSpec):
        # not posssible
        return None

    raise Exception(f'TODO: no code to get a type-match expr for {spec!r}')


def _getFilterBlock(
    input: Union[PanVar, PanIndexAccess, PanKeyAccess],
    label: str,
    spec: TypeSpec,
    names: Names,
) -> Statement:
    """
    Return a paradox Statement that will raise an RuntimeException on incorrect values.

    This method raises a _FilterNotPossible exception if the TypeSpec doesnt support it (e.g. for
    Dataclasses).
    """
    if isinstance(spec, NullTypeSpec):
        raise Exception(f"TODO: get a filter block for {spec!r}")  # noqa
        # just need a block that raises TypeError if the thing isn't None
        cond = ConditionalBlock(not_(isnull(input)))
        cond.alsoRaise("TypeError", msg=f"{label} must be None")
        return cond

    if isinstance(spec, ScalarTypeSpec):
        ret = Statements()

        # just need to make sure the thing is an instance of the correct scalar type
        if spec.scalarType is str:
            with ret.withCond(not_(isstr(input))) as cond:
                cond.alsoRaise(
                    "RuntimeException", msg=f"{label} should be of type string")
        elif spec.scalarType is bool:
            with ret.withCond(not_(isbool(input))) as cond:
                cond.alsoRaise(
                    "RuntimeException", msg=f"{label} should be of type boolean")
        else:
            __expr = spec  # TODO: remove this debug
            print('spec = %s:' % type(__expr))
            for _ in dir(__expr):
                if not hasattr(__expr, _):
                    print('  .%s = <not set>' % _)
                elif callable(getattr(__expr, _)):
                    print('  .%s()' % _)
                else:
                    print('  .%s = %r' % (_, getattr(__expr, _)))
            print('}')
            del __expr  # TODO: remove this debug
            raise Exception(f"TODO: get a filter block for {spec!r}")  # noqa

        return ret

    if isinstance(spec, ListTypeSpec):
        ret = Statements()

        # make sure the thing came back as a list
        with ret.withCond(not_(islist(input))) as cond:
            cond.alsoRaise("RuntimeException", msg=f"{label} should be of type array")

        # run a filter over all items
        itemspec = spec.itemSpec
        v_item = PanVar(names.getNewName(input, 'item', False), itemspec.getCrossType())
        with ret.withFor(v_item, input) as loop:
            # TODO: also if we want to provide meaningful error messages, we really want to know
            # the idx of the item that was broken and include it in the error message
            loop.also(_getFilterBlock(v_item, f"{label}[$n]", itemspec, names))

        return ret

    if isinstance(spec, DictTypeSpec):
        raise Exception(f"TODO: get a filter block for {spec!r}")  # noqa
        ret = Statements()

        # make sure the thing came back as a dict
        with ret.withCond(pyexpr(f'not isinstance({var_or_prop}, dict)')) as cond:
            cond.alsoRaise("TypeError", msg=f"{var_or_prop} should be of type dict")

        # make sure all dict keys/values have the correct type
        keyspec = spec.keySpec
        assert isinstance(keyspec, ScalarTypeSpec)
        assert keyspec.originalType is str
        valuespec = spec.valueSpec
        valuevar = names.getNewName(var_or_prop, 'value', False)
        with ret.withFor(PanVar(valuevar, None), pyexpr(f'{var_or_prop}.values()')) as loop:
            # TODO: also if we want to provide meaningful error messages, we really want to know
            # the key of the item that was broken and include it in the error message
            loop.also(_getFilterBlock(valuevar, f"{label}[$key]", valuespec, names))

        return ret

    if isinstance(spec, UnionTypeSpec):
        # make a list of simple expressions that can be used to verify simple types quickly
        simpleexprs: List[PanExpr] = []

        for vspec in spec.variants:
            nomatchexpr = _getTypeNoMatchExpr(input, vspec)
            if nomatchexpr is None:
                raise _FilterNotPossible(
                    f"UnionTypeSpec contains non-simple values and needs a converter block"
                )

            simpleexprs.append(nomatchexpr)

        assert len(simpleexprs)

        # if they were all simple, we can use a single negative-if to rule out some invalid types
        ret = Statements()

        with ret.withCond(and_(*simpleexprs)) as cond:
            cond.alsoRaise(
                "RuntimeException",
                msg=f"{input.getPHPExpr()[0]} did not match any variant",
            )

        return ret

    raise _FilterNotPossible(
        f"Not possible to build a Filter block for {spec}"
    )


def _getConverterBlock(
    input: Union[PanVar, PanIndexAccess, PanKeyAccess],
    output: PanVar,
    label: str,
    spec: TypeSpec,
    names: Names,
    adv: Advanced,
) -> Statement:
    """
    Return a paradox Statement that will convert target to the right type.

    The converted value is assigned to `output`. A TypeError is raised by the generated code block
    if `input` can't be converted.
    """
    if isinstance(input, PanVar):
        assert input.rawname != output.rawname

    if not names.isAssignable(output.rawname):
        raise Exception(
            f"Can't generate a converter to build {spec}"
            f" when {output} is not assignable"
        )

    if isinstance(spec, ListTypeSpec):
        ret = Statements()

        # make sure the thing came back as a list
        with ret.withCond(not_(islist(input))) as cond:
            cond.alsoRaise("RuntimeException", msg=f"{label} should be an array")

        ret.alsoAssign(output, phpexpr('[]'))

        # add converts for the items - we know filter blocks aren't possible because if they were,
        # we wouldn't be using _getConverterBlock on a ListTypeSpec
        itemspec = spec.itemSpec
        itemvar = PanVar(names.getNewName(input, 'item', False), itemspec.getCrossType())
        with ret.withFor(itemvar, input) as loop:
            # TODO: also if we want to provide meaningful error messages, we really want to know
            # the idx of the item that was broken and include it in the error message
            itemvar2 = PanVar(
                names.getNewName(input, 'item_converted', True),
                itemspec.getCrossType(),
            )
            loop.also(_getConverterBlock(
                itemvar,
                itemvar2,
                f"{label}[$n]",
                itemspec,
                names,
                adv,
            ))
            loop.alsoAppend(output, itemvar2)

        return ret

    if isinstance(spec, DataclassTypeSpec):
        if not adv.hasDataclass(spec.class_):
            raise Exception(
                f'Cannot generate a converter for unknown dataclass {spec.class_.__name__}')

        ret = Statements()
        ret.remark(f'try and build a {spec.class_.__name__} from {label}')
        ret.alsoAssign(output, PanCall(
            f'{spec.class_.__name__}.fromDict',
            input,
            pan(label),
        ))
        return ret

    if isinstance(spec, UnionTypeSpec):
        ret = Statements()

        # make a list of simple expressions that can be used to verify simple types quickly, and a
        # list of TypeSpecs for which simple expressions aren't possible
        notsimple: List[TypeSpec] = []
        simpleexprs: List[str] = []

        for vspec in spec.variants:
            nomatchexpr = _getTypeNoMatchExpr(var_or_prop, vspec)
            if nomatchexpr is None:
                notsimple.append(vspec)
            else:
                simpleexprs.append(nomatchexpr)

        # if they were all simple, we can use a single negative-if to rule out some invalid types
        if simpleexprs:
            innerstmt: Statements = ConditionalBlock(and_(*simpleexprs))
            ret.also(innerstmt)
        else:
            innerstmt = ret

        if len(notsimple):
            # make sure we can assign a new value to var_or_prop
            if var_or_prop != 'result' and not names.isAssignable(var_or_prop):
                raise Exception(f"Overwriting {var_or_prop} won't work")

            # use a nested function for flow-control ... mostly so we can use 'return' statements
            # to break out of the function early if we find a matching type
            checkername = names.getNewName('', 'checker', False)
            innercheck = FunctionSpec(checkername, CrossAny())
            checkervar = innercheck.addPositionalArg(
                names.getNewName('', 'value', True),
                CrossAny(),
            )
            innerstmt.also(innercheck)
            innerstmt.alsoAssign(PanVar(var_or_prop, None),
                                 PanCall(checkername, PanVar(var_or_prop, None)))
            innerstmt = innercheck

        for vspec in notsimple:
            innerstmt.remark('add a try/except for each vspec')
            with innerstmt.withTryBlock() as tryblock:
                filterblock = convertblock = None
                try:
                    filterblock = _getFilterBlock(checkervar, label, vspec, names)
                except _FilterNotPossible:
                    convertedvar = names.getNewName(checkervar, 'converted', True)
                    convertblock = _getConverterBlock(
                        checkervar,
                        convertedvar,
                        label,
                        vspec,
                        names,
                        adv,
                    )

                if filterblock:
                    tryblock.also(filterblock)
                    tryblock.alsoReturn(PanVar(checkervar, None))
                else:
                    assert convertblock is not None
                    tryblock.also(convertblock)
                    tryblock.alsoReturn(PanVar(convertedvar, None))
                with tryblock.withCatchBlock('TypeError') as catchblock:
                    catchblock.remark('ignore TypeError -contine on to next variant')
                    catchblock.also(pyexpr('pass'))
        innerstmt.alsoRaise("TypeError", msg=f"{var_or_prop} did not match any variant")
        return ret

    raise Exception(
        f"No code to generate a converter block for {var_or_prop} using {spec!r}"
    )
