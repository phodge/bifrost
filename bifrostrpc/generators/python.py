from typing import List, Tuple

from paradox.expressions import (PanCall, PanStringBuilder, PanVar, exacteq_,
                                 not_, pan, pandict, pyexpr)
from paradox.generate.statements import (ClassSpec, DictBuilderStatement,
                                         FunctionSpec)
from paradox.output import Script
from paradox.typing import (CrossAny, CrossCallable, CrossCustomType, CrossStr,
                            dictof, unionof)

from bifrostrpc import Flavour
from bifrostrpc.generators import Names
from bifrostrpc.generators.common import appendFailureModeClasses
from bifrostrpc.generators.conversion import (ConverterNotPossible,
                                              FilterNotPossible,
                                              getConverterBlock,
                                              getConverterExpr,
                                              getDataclassSpec, getFilterBlock)
from bifrostrpc.typing import Advanced, FuncSpec, _generateCrossType

HEADER = 'generated by Bifrost RPC'


T_ApiFailure = CrossCustomType(python='ApiFailure')


def generateClient(
    dest: Script,
    *,
    classname: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    adv: Advanced,
    flavour: Flavour,
) -> None:
    dest.add_file_comment(HEADER)

    # add new types to top of file
    for name, base in adv.getNewTypesAndBases():
        dest.add_new_type(name, base)

    appendFailureModeClasses(dest)

    # make copies of all our dataclasses
    for dc in adv.getAllDataclasses():
        dest.also(getDataclassSpec(dc, adv=adv, lang='python', hoistcontext=dest))

    # generate function wrappers
    dest.also(_generateClientClass(
        classname,
        funcspecs,
        adv=adv,
        flavour=flavour,
    ))


def _generateClientClass(
    classname: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    *,
    adv: Advanced,
    flavour: Flavour,
) -> ClassSpec:
    cls = ClassSpec(
        classname,
        isabstract=flavour == 'abstract',
        # TODO: we really should have a docstring for this
    )

    # add an dispatch() function that is used for all methods
    dispatchfn = cls.createMethod(
        '_dispatch',
        unionof(T_ApiFailure, CrossAny()),
        isabstract=flavour == 'abstract',
    )

    # the method that should be called
    v_method = dispatchfn.addPositionalArg('method', str)
    # a dict of params to pass to the method
    v_params = dispatchfn.addPositionalArg('params', dictof(str, CrossAny()))
    # converter will be called with the result of the method call.
    # It may modify result before returning it. It may raise a TypeError
    # if any part of result does not match the method's return type.
    dispatchfn.addPositionalArg('converter', CrossCallable([CrossAny()], CrossAny()))

    if flavour == 'requests':
        # if the flavour is 'requests', then we want to add host/port constructor args to the class
        p_host = cls.addProperty('host', str, initarg=True, tsreadonly=True)
        p_port = cls.addProperty('port', int, initarg=True, tsreadonly=True)

        # we need to initialise a requests.Session instance so that HTTP sessions and connection
        # pooling are available
        cls.alsoImportPy('requests')
        p_session = cls.addProperty(
            '_session',
            CrossCustomType(python='requests.Session'),
            default=PanCall('requests.Session'),
        )

        urlexpr = PanStringBuilder([
            pan('http://'),
            p_host,
            pan(':'),
            p_port,
            pan('/api.v1/call/'),
            v_method,
        ])
        v_url = dispatchfn.alsoDeclare('url', str, urlexpr)
        v_headers = dispatchfn.alsoDeclare('headers', "no_type", pandict({
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        }))
        dispatchfn.alsoImportPy('requests')
        v_result = dispatchfn.alsoDeclare('result', "no_type", PanCall(
            p_session.getprop('post'),
            v_url,
            json=v_params,
            headers=v_headers,
        ))
        statuscodeexpr = v_result.getprop('status_code', type=CrossAny())

        # return ApiUnauthorized when 401 response received
        with dispatchfn.withCond(exacteq_(statuscodeexpr, 401)) as cond:
            cond.alsoReturn(PanCall('ApiUnauthorized', PanStringBuilder([
                pan('Unexpected HTTP '),
                statuscodeexpr,
                pan(' response from rpc server: '),
                v_result.getprop('text'),
            ])))

        # TODO: return ApiBroken instead when appropriate
        # TODO: have more descriptive errors for various kinds of HTTP responses
        with dispatchfn.withCond(not_(exacteq_(statuscodeexpr, 200))) as cond:
            cond.alsoReturn(PanCall('ApiOutage', PanStringBuilder([
                pan('Status Code '),
                statuscodeexpr,
                pan(': '),
                v_result.getprop('text', type=CrossAny()),
            ])))
        dispatchfn.remark('read JSON blob or bomb out')
        with dispatchfn.withTryBlock() as tryblock:
            v_data = tryblock.alsoDeclare('data', 'no_type', PanCall('result.json'))
            with tryblock.withCatchBlock2(PanVar('e', None), pyclass='Exception') as catchblock:
                catchblock.alsoReturn(PanCall('ApiBroken', PanStringBuilder([
                    pan('Response was not valid JSON: '),
                    pyexpr('e.args[0]'),
                ])))
        dispatchfn.remark('convert from JSON to real types')
        with dispatchfn.withTryBlock() as tryblock:
            v_ret = tryblock.alsoDeclare('ret', 'no_type', PanCall('converter', v_data))
            with tryblock.withCatchBlock2(PanVar('e', None), pyclass='TypeError') as catchblock:
                catchblock.alsoReturn(PanCall('ApiBroken', PanStringBuilder([
                    pan('Response data from '),
                    v_method,
                    pan(' was invalid: '),
                    pyexpr('e.args[0]'),
                ])))
        dispatchfn.alsoReturn(v_ret)
    else:
        assert flavour == 'abstract'

    for name, funcspec in funcspecs:
        retspec = funcspec.getReturnSpec()

        # build a custom converter function for this method
        conv = FunctionSpec('_converter', CrossAny())
        v_result = conv.addPositionalArg('result', CrossAny())
        names = Names()

        try:
            filterblock = getFilterBlock(
                v_result,
                label='$DATA',
                spec=retspec,
                names=names,
                lang='python',
            )
            conv.also(filterblock)
            conv.alsoReturn(v_result)
        except FilterNotPossible:
            try:
                conv.alsoReturn(getConverterExpr(
                    v_result,
                    label='$DATA',
                    spec=retspec,
                    adv=adv,
                    lang='python',
                ))
            except ConverterNotPossible:
                v_converted = names.getSpecificName('converted', True)
                conv.also(getConverterBlock(
                    v_result,
                    v_converted,
                    label='$DATA',
                    spec=retspec,
                    names=names,
                    adv=adv,
                    lang='python',
                    hoistcontext=conv,
                ))
                conv.alsoReturn(v_converted)

        rettype = unionof(T_ApiFailure, _generateCrossType(retspec, adv))
        method = cls.createMethod(name, rettype)

        for argname, spec in funcspec.getArgSpecs().items():
            method.addPositionalArg(argname, _generateCrossType(spec, adv))

        v_args = PanVar('args', dictof(str, CrossAny()))
        argnames = DictBuilderStatement.fromPanVar(v_args)
        for n in funcspec.getArgSpecs().keys():
            # TODO: dataclasses aren't automatically JSON serializable, so we need to raise an
            # error if we try to generate a client that has a dataclass argument type
            argnames.addPair(n, False)
        method.also(argnames)

        method.blank()
        method.remark(
            'include [__dataclass__] in returned values so that we can rebuild dataclasses',
        )
        method.alsoAssign(v_args["__showdataclass__"], True)

        method.also(conv)

        method.alsoReturn(PanCall(
            'self._dispatch',
            pan(name),
            v_args,
            pyexpr('_converter'),
        ))

    return cls
