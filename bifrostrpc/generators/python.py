from typing import List, Tuple

from paradox.expressions import PanCall, PanVar, pan, pyexpr
from paradox.generate.files import FilePython
from paradox.generate.statements import (ClassSpec, DictBuilderStatement,
                                         FunctionSpec)
from paradox.typing import (CrossAny, CrossCallable, CrossNewType, dictof,
                            unionof)

from bifrostrpc import Flavour
from bifrostrpc.generators import Names
from bifrostrpc.generators.common import appendFailureModeClasses
from bifrostrpc.generators.conversion import (ConverterNotPossible,
                                              FilterNotPossible,
                                              getConverterBlock,
                                              getConverterExpr,
                                              getDataclassSpec, getFilterBlock)
from bifrostrpc.typing import Advanced, FuncSpec, _generateCrossType

HEADER = 'generated by Bifrost RPC'


def generateClient(
    dest: FilePython,
    *,
    classname: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    adv: Advanced,
    flavour: Flavour,
) -> None:
    dest.filecomment(HEADER)

    # we're always going to need typing module
    dest.contents.alsoImportPy("typing")

    appendFailureModeClasses(dest)

    # make copies of all our dataclasses
    for dc in adv.getAllDataclasses():
        dcspec = getDataclassSpec(dc, adv=adv, lang='python')
        dest.contents.also(dcspec)

    # generate function wrappers
    dest.contents.also(_generateWrappers(classname, funcspecs, adv, flavour))

    dest.writefile()
    dest.makepretty()


def _generateWrappers(
    classname: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    adv: Advanced,
    flavour: Flavour,
) -> ClassSpec:
    cls = ClassSpec(
        classname,
        isabstract=flavour == 'abstract',
        # TODO: we really should have a docstring for this
    )

    # add an dispatch() function that is used for all methods
    cls.alsoImportPy('typing')
    dispatchfn = cls.createMethod(
        '_dispatch',
        unionof(CrossNewType('ApiFailure'), CrossAny()),
        isabstract=flavour == 'abstract',
    )

    # the method that should be called
    dispatchfn.addPositionalArg('method', str)
    # a dict of params to pass to the method
    dispatchfn.addPositionalArg('params', dictof(str, CrossAny()))
    # converter will be called with the result of the method call.
    # It may modify result before returning it. It may raise a TypeError
    # if any part of result does not match the method's return type.
    dispatchfn.addPositionalArg('converter', CrossCallable([CrossAny()], CrossAny()))

    if flavour == 'requests':
        # TODO: finish this
        dispatchfn.alsoRaise(
            msg="TODO: perform the request using requests library"
        )
    else:
        assert flavour == 'abstract'
        # TODO: abstract function should get '...' body automatically?
        # dispatchfn.also('...')

    for name, funcspec in funcspecs:
        retspec = funcspec.getReturnSpec()

        # build a custom converter function for this method
        conv = FunctionSpec('_converter', CrossAny())
        v_result = conv.addPositionalArg('result', CrossAny())
        names = Names()

        try:
            filterblock = getFilterBlock(v_result, label='$DATA', spec=retspec, names=names, lang='python')
            conv.also(filterblock)
            conv.alsoReturn(v_result)
        except FilterNotPossible:
            try:
                conv.alsoReturn(getConverterExpr(
                    v_result,
                    label='$DATA',
                    spec=retspec,
                    names=names,
                    adv=adv,
                    lang='python',
                ))
            except ConverterNotPossible:
                v_converted = names.getSpecificName('converted', True)
                conv.also(getConverterBlock(
                    v_result,
                    v_converted,
                    label='$DATA',
                    spec=retspec,
                    names=names,
                    adv=adv,
                    lang='python',
                    hoistcontext=conv,
                ))
                conv.alsoReturn(v_converted)

        rettype = unionof(CrossNewType('ApiFailure'), _generateCrossType(retspec, adv))
        method = cls.createMethod(name, rettype)

        for argname, spec in funcspec.getArgSpecs().items():
            method.addPositionalArg(argname, _generateCrossType(spec, adv))

        v_args = PanVar('args', dictof(str, CrossAny()))
        argnames = DictBuilderStatement.fromPanVar(v_args)
        for n in funcspec.getArgSpecs().keys():
            # TODO: dataclasses aren't automatically JSON serializable, so we need to raise an
            # error if we try to generate a client that has a dataclass argument type
            argnames.addPair(n, False)
        method.also(argnames)

        method.blank()
        method.remark(
            'include [__dataclass__] in returned values so that we can rebuild dataclasses',
        )
        method.alsoAssign(v_args["__showdataclass__"], True)

        method.also(conv)

        method.alsoReturn(PanCall(
            'self._dispatch',
            pan(name),
            v_args,
            pyexpr('_converter'),
        ))

    return cls
