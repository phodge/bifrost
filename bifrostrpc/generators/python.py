from typing import Any, Callable, List, Optional, Tuple, Type

import dataclasses
from paradox.expressions import PanCall, PanExpr, PanVar, pan, pyexpr
from paradox.generate.files import FilePython
from paradox.generate.statements import (ClassSpec, ConditionalBlock,
                                         DictBuilderStatement, FunctionSpec,
                                         Statement, Statements)
from paradox.typing import (CrossAny, CrossCallable, CrossNewType, dictof,
                            unionof)

from bifrostrpc import Flavour
from bifrostrpc.generators import Names
from bifrostrpc.generators.common import appendFailureModeClasses
from bifrostrpc.typing import (Advanced, DataclassTypeSpec, DictTypeSpec,
                               FuncSpec, ListTypeSpec, LiteralTypeSpec,
                               NullTypeSpec, ScalarTypeSpec, TypeSpec,
                               UnionTypeSpec, _generateCrossType, getTypeSpec)

HEADER = 'generated by Bifrost RPC'


class _FilterNotPossible(Exception):
    pass


def generateClient(
    dest: FilePython,
    *,
    classname: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    adv: Advanced,
    flavour: Flavour,
) -> None:
    dest.filecomment(HEADER)

    # we're always going to need typing module
    dest.contents.alsoImportPy("typing")

    appendFailureModeClasses(dest)

    # make copies of all our dataclasses
    for dc in adv.getAllDataclasses():
        dcspec = _getDataclassSpec(dc, adv)
        dest.contents.also(dcspec)

    # generate function wrappers
    dest.contents.also(_generateWrappers(classname, funcspecs, adv, flavour))

    dest.writefile()
    dest.makepretty()


def _generateWrappers(
    classname: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    adv: Advanced,
    flavour: Flavour,
) -> ClassSpec:
    cls = ClassSpec(
        classname,
        isabstract=flavour == 'abstract',
        # TODO: we really should have a docstring for this
    )

    # add an dispatch() function that is used for all methods
    cls.alsoImportPy('typing')
    dispatchfn = cls.createMethod(
        '_dispatch',
        unionof(CrossNewType('ApiFailure'), CrossAny()),
        isabstract=flavour == 'abstract',
    )

    def addimport(module: str) -> None:
        cls.alsoImportPy(module)

    # the method that should be called
    dispatchfn.addPositionalArg('method', str)
    # a dict of params to pass to the method
    dispatchfn.addPositionalArg('params', dictof(str, CrossAny()))
    # converter will be called with the result of the method call.
    # It may modify result before returning it. It may raise a TypeError
    # if any part of result does not match the method's return type.
    dispatchfn.addPositionalArg('converter', CrossCallable([CrossAny()], CrossAny()))

    if flavour == 'requests':
        # TODO: finish this
        dispatchfn.alsoRaise(
            msg="TODO: perform the request using requests library"
        )
    else:
        assert flavour == 'abstract'
        # TODO: abstract function should get '...' body automatically?
        # dispatchfn.also('...')

    for name, funcspec in funcspecs:
        retspec = funcspec.getReturnSpec()

        # build a custom converter function for this method
        conv = FunctionSpec('_converter', CrossAny())
        v_result = conv.addPositionalArg('result', CrossAny())
        names = Names()

        try:
            filterblock = _getFilterBlock('result', '$DATA', retspec, names)
            conv.also(filterblock)
        except _FilterNotPossible:
            names.getSpecificName('converted', True)
            conv.also(_getConverterBlock('result', 'converted', '$DATA', retspec, names, adv))
            conv.alsoReturn(PanVar('converted', None))
        else:
            conv.alsoReturn(v_result)

        rettype = unionof(CrossNewType('ApiFailure'), _generateCrossType(retspec, adv))
        method = cls.createMethod(name, rettype)

        for argname, spec in funcspec.getArgSpecs().items():
            method.addPositionalArg(argname, _generateCrossType(spec, adv))

        v_args = PanVar('args', dictof(str, CrossAny()))
        argnames = DictBuilderStatement.fromPanVar(v_args)
        for n in funcspec.getArgSpecs().keys():
            # TODO: dataclasses aren't automatically JSON serializable, so we need to raise an
            # error if we try to generate a client that has a dataclass argument type
            argnames.addPair(n, False)
        method.also(argnames)

        method.blank()
        method.remark(
            'include [__dataclass__] in returned values so that we can rebuild dataclasses',
        )
        method.alsoAssign(v_args["__showdataclass__"], True)

        method.also(conv)

        method.alsoReturn(PanCall(
            'self._dispatch',
            pan(name),
            v_args,
            pyexpr('_converter'),
        ))

    # TODO: rather than writing to the file pointer, we should really be returning the class
    return cls


def _getDataclassSpec(
    dc: Type[Any],
    adv: Advanced,
) -> ClassSpec:
    name = dc.__name__
    cls = ClassSpec(name, isdataclass=True)

    for field in dataclasses.fields(dc):
        fieldspec = getTypeSpec(field.type, adv)
        cls.addProperty(field.name, _generateCrossType(fieldspec, adv))

    # the dataclass needs a deserialization method, too
    fromdict = cls.createMethod('fromDict', CrossNewType(name, quoted=True), isstaticmethod=True)
    fromdict.addPositionalArg('data', CrossAny())
    fromdict.addPositionalArg('label', str)

    # constructor part 1 - ensure the provided data is a dict
    with fromdict.withCond(pyexpr('not isinstance(data, dict)')) as cond:
        cond.alsoRaise("TypeError", expr=pyexpr('f"{label} must be a dict"'))

    # constructor part 2 - ensure the __dataclass__ item is present
    with fromdict.withCond(pyexpr(f'data.get("__dataclass__") != {name!r}')) as cond:
        cond.alsoRaise("TypeError",
                       expr=pyexpr('f"{label}[\'__dataclass__\'] must be %s"' % repr(name)))

    names = Names()

    buildargs: List[PanExpr] = []

    # validate each property item
    for field in dataclasses.fields(dc):
        # use a try/catch to assign the dict key to a local variable before we filter/convert it.
        # This allows us to trap the KeyError quickly and explicitly
        fname = field.name
        varname = names.getNewName('', fname, True)
        v_var = PanVar(varname, CrossAny())
        with fromdict.withTryBlock() as tryblock:
            tryblock.alsoDeclare(v_var, None, pyexpr(f'data[{fname!r}]'))
            with tryblock.withCatchBlock('KeyError') as caught:
                caught.alsoRaise("TypeError",
                                 expr=pyexpr('f"{label}[\'%s\'] is missing"' % fname))
        fieldspec = getTypeSpec(field.type, adv)

        # check the local variable's type
        try:
            fromdict.also(_getFilterBlock(varname, f"data[{fname!r}]", fieldspec, names))
        except _FilterNotPossible:
            stmts = Statements()
            copyname = names.getNewName(varname, 'converted', True)
            stmts.also(_getConverterBlock(
                varname,
                copyname,
                f"data[{fname!r}]", fieldspec, names, adv,
            ))
            stmts.alsoAssign(v_var, PanVar(copyname, CrossAny()))
            fromdict.also(stmts)

        buildargs.append(v_var)

    fromdict.alsoReturn(PanCall(name, *buildargs))

    return cls


def _generateType(spec: TypeSpec, adv: Advanced, addimport: Callable[[str], None]) -> str:
    if isinstance(spec, NullTypeSpec):
        return 'None'

    if isinstance(spec, ScalarTypeSpec):
        return spec.typeName

    if isinstance(spec, ListTypeSpec):
        itemtype = _generateType(spec.itemSpec, adv, addimport)
        return f'typing.List[{itemtype}]'

    if isinstance(spec, DictTypeSpec):
        keytype = _generateType(spec.keySpec, adv, addimport)
        valuetype = _generateType(spec.valueSpec, adv, addimport)
        return f'typing.Dict[{keytype}, {valuetype}]'

    if isinstance(spec, DataclassTypeSpec):
        if not adv.hasDataclass(spec.class_):
            raise Exception(
                f'Cannot generate a python type for unknown dataclass {spec.class_.__name__}')

        return spec.class_.__name__

    if isinstance(spec, UnionTypeSpec):
        joined = ", ".join([
            _generateType(variantspec, adv, addimport)
            for variantspec in spec.variants
        ])
        return f'typing.Union[{joined}]'

    if isinstance(spec, LiteralTypeSpec):
        if spec.expectedType is bool:
            raise Exception("TODO: test this code path")  # noqa
            addimport('typing_extensions')  # pylint: disable=unreachable
            return f'typing_extensions.Literal[{spec.expected!r}]'

        if spec.expectedType is int:
            raise Exception("TODO: test this code path")  # noqa
            addimport('typing_extensions')  # pylint: disable=unreachable
            return f'typing_extensions.Literal[{spec.expected}]'

        if spec.expectedType is not str:
            raise Exception(f"Unexpected literal type {spec.expectedType.__name__}")

        addimport('typing_extensions')
        return f'typing_extensions.Literal[{spec.expected!r}]'

    raise Exception(f"TODO: generate a type for {spec!r}")


def _getTypeNoMatchExpr(var_or_prop: str, spec: TypeSpec) -> Optional[str]:
    if isinstance(spec, NullTypeSpec):
        return f'{var_or_prop} is not None'

    if isinstance(spec, ScalarTypeSpec):
        return f'not isinstance({var_or_prop}, {spec.scalarType.__name__})'

    if isinstance(spec, LiteralTypeSpec):
        if spec.expectedType is bool:
            return f'{var_or_prop} is not {spec.expected!r}'

        assert spec.expectedType in (int, str)
        what = spec.expectedType.__name__
        return f'not (isinstance({var_or_prop}, {what}) and {var_or_prop} == {spec.expected})'

    if isinstance(spec, DataclassTypeSpec):
        # not possible
        return None

    if isinstance(spec, ListTypeSpec):
        if isinstance(spec.itemSpec, NullTypeSpec):
            return f'any(x is not None for x in {var_or_prop})'

        itemSpec = spec.itemSpec
        if isinstance(itemSpec, ScalarTypeSpec):
            scalarName = itemSpec.scalarType.__name__
            return f'not all(isinstance(x, {scalarName}) for x in {var_or_prop})'

        # not possible
        return None

    raise Exception(f'TODO: no code to get a type-match expr for {spec!r}')


def _getFilterBlock(
    var_or_prop: str,
    label: str,
    spec: TypeSpec,
    names: Names,
) -> Statement:
    """
    Return a paradox Statement that will raise a TypeError on incorrect values.

    This method raises a _FilterNotPossible exception if the TypeSpec doesnt support it (e.g. for
    Dataclasses).
    """
    if isinstance(spec, NullTypeSpec):
        # just need a block that raises TypeError if the thing isn't None
        cond = ConditionalBlock(pyexpr(f'{var_or_prop} is not None'))
        cond.alsoRaise("TypeError", msg=f"{label} must be None")
        return cond

    if isinstance(spec, ScalarTypeSpec):
        ret = Statements()

        # just need to make sure the thing is an instance of the correct scalar type
        primitivename = spec.scalarType.__name__
        with ret.withCond(pyexpr(f'not isinstance({var_or_prop}, {primitivename})')) as cond:
            cond.alsoRaise("TypeError", msg=f"{label} should be of type {primitivename}")

        return ret

    if isinstance(spec, ListTypeSpec):
        ret = Statements()

        # make sure the thing came back as a list
        with ret.withCond(pyexpr(f'not isinstance({var_or_prop}, list)')) as cond:
            cond.alsoRaise("TypeError", msg=f"{label} should be of type list")

        # run a filter over all items
        itemspec = spec.itemSpec
        itemvar = names.getNewName(var_or_prop, 'item', False)
        with ret.withFor(PanVar(itemvar, None), pyexpr(var_or_prop)) as loop:
            # TODO: also if we want to provide meaningful error messages, we really want to know
            # the idx of the item that was broken and include it in the error message
            loop.also(_getFilterBlock(itemvar, f"{label}[$n]", itemspec, names))

        return ret

    if isinstance(spec, DictTypeSpec):
        ret = Statements()

        # make sure the thing came back as a dict
        with ret.withCond(pyexpr(f'not isinstance({var_or_prop}, dict)')) as cond:
            cond.alsoRaise("TypeError", msg=f"{var_or_prop} should be of type dict")

        # make sure all dict keys/values have the correct type
        keyspec = spec.keySpec
        assert isinstance(keyspec, ScalarTypeSpec)
        assert keyspec.originalType is str
        valuespec = spec.valueSpec
        valuevar = names.getNewName(var_or_prop, 'value', False)
        with ret.withFor(PanVar(valuevar, None), pyexpr(f'{var_or_prop}.values()')) as loop:
            # TODO: also if we want to provide meaningful error messages, we really want to know
            # the key of the item that was broken and include it in the error message
            loop.also(_getFilterBlock(valuevar, f"{label}[$key]", valuespec, names))

        return ret

    if isinstance(spec, UnionTypeSpec):
        # make a list of simple expressions that can be used to verify simple types quickly, and a
        # list of TypeSpecs for which simple expressions aren't possible
        simpleexprs: List[str] = []

        for vspec in spec.variants:
            nomatchexpr = _getTypeNoMatchExpr(var_or_prop, vspec)
            if nomatchexpr is None:
                raise _FilterNotPossible(
                    "UnionTypeSpec contains non-simple values and needs a converter block"
                )

            simpleexprs.append(nomatchexpr)

        assert simpleexprs

        # if they were all simple, we can use a single negative-if to rule out some invalid types
        ret = Statements()

        with ret.withCond(pyexpr(' and '.join(simpleexprs))) as cond:
            cond.alsoRaise("TypeError", msg=f"{var_or_prop} did not match any variant")

        return ret

    raise _FilterNotPossible(
        f"Not possible to build a Filter block for {spec}"
    )


def _getConverterBlock(
    var_or_prop: str,
    outname: str,
    label: str,
    spec: TypeSpec,
    names: Names,
    adv: Advanced,
) -> Statement:
    """
    Return a paradox Statement that will convert var_or_prop to the right type.

    The converted value is assigned to `outname`. A TypeError is raised by the generated code block
    if `var_or_prop` can't be converted.
    """
    assert outname != var_or_prop

    if not names.isAssignable(outname):
        raise Exception(
            f"Can't generate a converter to build {spec}"
            f" when {outname} is not assignable"
        )

    if isinstance(spec, ListTypeSpec):
        ret = Statements()

        # make sure the thing came back as a list
        with ret.withCond(pyexpr(f'not isinstance({var_or_prop}, list)')) as cond:
            cond.alsoRaise("TypeError", msg=f"{label} should be of type list")

        ret.alsoAssign(PanVar(outname, None), pyexpr('[]'))

        # add converts for the items - we know filter blocks aren't possible because if they were,
        # we wouldn't be using _getConverterBlock on a ListTypeSpec
        itemspec = spec.itemSpec
        itemvar = names.getNewName(var_or_prop, 'item', False)
        with ret.withFor(PanVar(itemvar, None), pyexpr(var_or_prop)) as loop:
            # TODO: also if we want to provide meaningful error messages, we really want to know
            # the idx of the item that was broken and include it in the error message
            itemvar2 = names.getNewName(var_or_prop, 'item_converted', True)
            loop.also(_getConverterBlock(
                itemvar,
                itemvar2,
                f"{label}[$n]",
                itemspec,
                names,
                adv,
            ))
            loop.also(pyexpr(f"{outname}.append({itemvar2})"))

        return ret

    if isinstance(spec, DataclassTypeSpec):
        if not adv.hasDataclass(spec.class_):
            raise Exception(
                f'Cannot generate a converter for unknown dataclass {spec.class_.__name__}')

        ret = Statements()
        ret.remark(f'try and build a {spec.class_.__name__} from {label}')
        ret.alsoAssign(PanVar(outname, None), PanCall(
            f'{spec.class_.__name__}.fromDict',
            PanVar(var_or_prop, None),
            pan(label),
        ))
        return ret

    if isinstance(spec, UnionTypeSpec):
        ret = Statements()

        # make a list of simple expressions that can be used to verify simple types quickly, and a
        # list of TypeSpecs for which simple expressions aren't possible
        notsimple: List[TypeSpec] = []
        simpleexprs: List[str] = []

        for vspec in spec.variants:
            nomatchexpr = _getTypeNoMatchExpr(var_or_prop, vspec)
            if nomatchexpr is None:
                notsimple.append(vspec)
            else:
                simpleexprs.append(nomatchexpr)

        # if they were all simple, we can use a single negative-if to rule out some invalid types
        if simpleexprs:
            innerstmt: Statements = ConditionalBlock(pyexpr(' and '.join(simpleexprs)))
            ret.also(innerstmt)
        else:
            innerstmt = ret

        if notsimple:
            # make sure we can assign a new value to var_or_prop
            if var_or_prop != 'result' and not names.isAssignable(var_or_prop):
                raise Exception(f"Overwriting {var_or_prop} won't work")

            # use a nested function for flow-control ... mostly so we can use 'return' statements
            # to break out of the function early if we find a matching type
            checkervar = names.getNewName('', 'value', True)
            checkername = names.getNewName('', 'checker', False)
            innercheck = FunctionSpec(checkername, CrossAny())
            innercheck.addPositionalArg(checkervar, CrossAny())
            innerstmt.also(innercheck)
            innerstmt.alsoAssign(PanVar(var_or_prop, None),
                                 PanCall(checkername, PanVar(var_or_prop, None)))
            innerstmt = innercheck

        for vspec in notsimple:
            innerstmt.remark('add a try/except for each vspec')
            with innerstmt.withTryBlock() as tryblock:
                filterblock = convertblock = None
                try:
                    filterblock = _getFilterBlock(checkervar, label, vspec, names)
                except _FilterNotPossible:
                    convertedvar = names.getNewName(checkervar, 'converted', True)
                    convertblock = _getConverterBlock(
                        checkervar,
                        convertedvar,
                        label,
                        vspec,
                        names,
                        adv,
                    )

                if filterblock:
                    tryblock.also(filterblock)
                    tryblock.alsoReturn(PanVar(checkervar, None))
                else:
                    assert convertblock is not None
                    tryblock.also(convertblock)
                    tryblock.alsoReturn(PanVar(convertedvar, None))
                with tryblock.withCatchBlock('TypeError') as catchblock:
                    catchblock.remark('ignore TypeError -contine on to next variant')
                    catchblock.also(pyexpr('pass'))
        innerstmt.alsoRaise("TypeError", msg=f"{var_or_prop} did not match any variant")
        return ret

    raise Exception(
        f"No code to generate a converter block for {var_or_prop} using {spec!r}"
    )
