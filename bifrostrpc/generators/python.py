from typing import Any, Callable, List, Optional, Tuple, Type

import dataclasses
from paradox.expressions import PanCall, PanExpr, PanVar, pan, pyexpr
from paradox.generate.files import FilePython
from paradox.generate.statements import (ClassSpec, ConditionalBlock,
                                         DictBuilderStatement, FunctionSpec,
                                         Statements)
from paradox.typing import (CrossAny, CrossCallable, CrossNewType, dictof,
                            unionof)

from bifrostrpc import Flavour
from bifrostrpc.generators import Names
from bifrostrpc.generators.common import appendFailureModeClasses
from bifrostrpc.typing import (Advanced, DataclassTypeSpec, DictTypeSpec,
                               FuncSpec, ListTypeSpec, LiteralTypeSpec,
                               NullTypeSpec, ScalarTypeSpec, TypeSpec,
                               UnionTypeSpec, _generateCrossType, getTypeSpec)

HEADER = 'generated by Bifrost RPC'


def generateClient(
    dest: FilePython,
    *,
    classname: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    adv: Advanced,
    flavour: Flavour,
) -> None:
    dest.filecomment(HEADER)

    # we're always going to need typing module
    dest.contents.alsoImportPy("typing")

    appendFailureModeClasses(dest)

    # make copies of all our dataclasses
    for dc in adv.getAllDataclasses():
        dcspec = _getDataclassSpec(dc, adv)
        dest.contents.also(dcspec)

    # generate function wrappers
    dest.contents.also(_generateWrappers(classname, funcspecs, adv, flavour))

    dest.writefile()
    dest.makepretty()


def _generateWrappers(
    classname: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    adv: Advanced,
    flavour: Flavour,
) -> ClassSpec:
    cls = ClassSpec(
        classname,
        isabstract=flavour == 'abstract',
        # TODO: we really should have a docstring for this
    )

    # add an dispatch() function that is used for all methods
    cls.alsoImportPy('typing')
    dispatchfn = cls.createMethod(
        '_dispatch',
        unionof(CrossNewType('ApiFailure'), CrossAny()),
        isabstract=flavour == 'abstract',
    )

    def addimport(module: str) -> None:
        cls.alsoImportPy(module)

    # the method that should be called
    dispatchfn.addPositionalArg('method', str)
    # a dict of params to pass to the method
    dispatchfn.addPositionalArg('params', dictof(str, CrossAny()))
    # converter will be called with the result of the method call.
    # It may modify result before returning it. It may raise a TypeError
    # if any part of result does not match the method's return type.
    dispatchfn.addPositionalArg('converter', CrossCallable([CrossAny()], CrossAny()))

    if flavour == 'requests':
        # TODO: finish this
        dispatchfn.alsoRaise(
            msg="TODO: perform the request using requests library"
        )
    else:
        assert flavour == 'abstract'
        # TODO: abstract function should get '...' body automatically?
        #dispatchfn.also('...')

    for name, funcspec in funcspecs:
        retspec = funcspec.getReturnSpec()

        # build a custom converter function for this method
        conv = FunctionSpec('_converter', CrossAny())
        v_result = conv.addPositionalArg('result', CrossAny())
        _generateConversion(conv, 'result', retspec, Names(), adv)
        conv.alsoReturn(v_result)

        rettype = unionof(CrossNewType('ApiFailure'), _generateCrossType(retspec, adv))
        method = cls.createMethod(name, rettype)

        for argname, spec in funcspec.getArgSpecs().items():
            method.addPositionalArg(argname, _generateCrossType(spec, adv))

        v_args = PanVar('args', dictof(str, CrossAny()))
        argnames = DictBuilderStatement.fromPanVar(v_args)
        for n in funcspec.getArgSpecs().keys():
            # TODO: dataclasses aren't automatically JSON serializable, so we need to raise an
            # error if we try to generate a client that has a dataclass argument type
            argnames.addPair(n, False)
        method.also(argnames)

        method.blank()
        method.remark(
            'include [__dataclass__] in returned values so that we can rebuild dataclasses',
        )
        method.alsoAssign(v_args["__showdataclass__"], True)

        method.also(conv)

        method.alsoReturn(PanCall(
            'self._dispatch',
            pan(name),
            v_args,
            pyexpr('_converter'),
        ))

    # TODO: rather than writing to the file pointer, we should really be returning the class
    return cls


def _getDataclassSpec(
    dc: Type[Any],
    adv: Advanced,
) -> ClassSpec:
    name = dc.__name__
    cls = ClassSpec(name, isdataclass=True)

    for field in dataclasses.fields(dc):
        fieldspec = getTypeSpec(field.type, adv)
        cls.addProperty(field.name, _generateCrossType(fieldspec, adv))

    # the dataclass needs a deserialization method, too
    fromdict = cls.createMethod('fromDict', CrossNewType(name, quoted=True), isstaticmethod=True)
    fromdict.addPositionalArg('data', CrossAny())
    fromdict.addPositionalArg('label', str)

    # constructor part 1 - ensure the provided data is a dict
    with fromdict.withCond(pyexpr('not isinstance(data, dict)')) as cond:
        cond.alsoRaise("TypeError", expr=pyexpr('f"{label} must be a dict"'))

    # constructor part 2 - ensure the __dataclass__ item is present
    with fromdict.withCond(pyexpr(f'data.get("__dataclass__") != {name!r}')) as cond:
        cond.alsoRaise("TypeError",
                       expr=pyexpr('f"{label}[\'__dataclass__\'] must be %s"' % repr(name)))

    names = Names()

    buildargs: List[PanExpr] = []

    # validate each property item
    for field in dataclasses.fields(dc):
        # use a try/catch to assign the dict key to a local variable
        fname = field.name
        varname = names.getNewName('', fname, True)
        v_var = PanVar(varname, CrossAny())
        with fromdict.withTryBlock() as tryblock:
            tryblock.alsoDeclare(v_var, None, pyexpr(f'data[{fname!r}]'))
            with tryblock.withCatchBlock('KeyError') as caught:
                caught.alsoRaise("TypeError",
                                 expr=pyexpr('f"{label}[\'%s\'] is missing"' % fname))
        fieldspec = getTypeSpec(field.type, adv)

        # check the local variable's type
        _generateConversion(fromdict, str(varname), fieldspec, names, adv)

        buildargs.append(v_var)

    fromdict.alsoReturn(PanCall(name, *buildargs))

    return cls


def _generateType(spec: TypeSpec, adv: Advanced, addimport: Callable[[str], None]) -> str:
    if isinstance(spec, NullTypeSpec):
        return 'None'

    if isinstance(spec, ScalarTypeSpec):
        return spec.typeName

    if isinstance(spec, ListTypeSpec):
        itemtype = _generateType(spec.itemSpec, adv, addimport)
        return f'typing.List[{itemtype}]'

    if isinstance(spec, DictTypeSpec):
        keytype = _generateType(spec.keySpec, adv, addimport)
        valuetype = _generateType(spec.valueSpec, adv, addimport)
        return f'typing.Dict[{keytype}, {valuetype}]'

    if isinstance(spec, DataclassTypeSpec):
        if not adv.hasDataclass(spec.class_):
            raise Exception(
                f'Cannot generate a python type for unknown dataclass {spec.class_.__name__}')

        return spec.class_.__name__

    if isinstance(spec, UnionTypeSpec):
        joined = ", ".join([
            _generateType(variantspec, adv, addimport)
            for variantspec in spec.variants
        ])
        return f'typing.Union[{joined}]'

    if isinstance(spec, LiteralTypeSpec):
        if spec.expectedType is bool:
            raise Exception("TODO: test this code path")  # noqa
            addimport('typing_extensions')
            return f'typing_extensions.Literal[{spec.expected!r}]'

        if spec.expectedType is int:
            raise Exception("TODO: test this code path")  # noqa
            addimport('typing_extensions')
            return f'typing_extensions.Literal[{spec.expected}]'

        if spec.expectedType is not str:
            raise Exception(f"Unexpected literal type {spec.expectedType.__name__}")

        addimport('typing_extensions')
        return f'typing_extensions.Literal[{spec.expected!r}]'

    raise Exception(f"TODO: generate a type for {spec!r}")


def _getTypeNoMatchExpr(var_or_prop: str, spec: TypeSpec) -> Optional[str]:
    if isinstance(spec, NullTypeSpec):
        return f'{var_or_prop} is not None'

    if isinstance(spec, ScalarTypeSpec):
        return f'not isinstance({var_or_prop}, {spec.scalarType.__name__})'

    if isinstance(spec, LiteralTypeSpec):
        if spec.expectedType is bool:
            return f'{var_or_prop} is not {spec.expected!r}'

        assert spec.expectedType in (int, str)
        what = spec.expectedType.__name__
        return f'not (isinstance({var_or_prop}, {what}) and {var_or_prop} == {spec.expected})'

    if isinstance(spec, DataclassTypeSpec):
        # not possible
        return None

    if isinstance(spec, ListTypeSpec):
        if isinstance(spec.itemSpec, NullTypeSpec):
            return f'any(x is not None for x in {var_or_prop})'

        itemSpec = spec.itemSpec
        if isinstance(itemSpec, ScalarTypeSpec):
            scalarName = itemSpec.scalarType.__name__
            return f'not all(isinstance(x, {scalarName}) for x in {var_or_prop})'

        # not possible
        return None

    raise Exception(f'TODO: no code to get a type-match expr for {spec!r}')


def _generateConversion(
    context: Statements,
    var_or_prop: str,
    spec: TypeSpec,
    names: Names,
    adv: Advanced,
) -> None:
    if isinstance(spec, ScalarTypeSpec):
        # make sure the thing has the correct type
        primitivename = spec.scalarType.__name__
        with context.withCond(pyexpr(f'not isinstance({var_or_prop}, {primitivename})')) as cond:
            cond.alsoRaise("TypeError", msg=f"{var_or_prop} should be of type {primitivename}")
        return

    if isinstance(spec, ListTypeSpec):
        # make sure the thing came back as a list
        with context.withCond(pyexpr(f'not isinstance({var_or_prop}, list)')) as cond:
            cond.alsoRaise("TypeError", msg=f"{var_or_prop} should be of type list")

        # make sure all items have the correct type
        itemspec = spec.itemSpec
        itemvar = names.getNewName(var_or_prop, 'item', False)
        with context.withFor(PanVar(itemvar, None), pyexpr(var_or_prop)) as loop:
            # TODO: also if we want to provide meaningful error messages, we really want to know
            # the idx of the item that was broken and include it in the error message
            _generateConversion(loop, itemvar, itemspec, names, adv)
        return

    if isinstance(spec, DictTypeSpec):
        # make sure the thing came back as a dict
        with context.withCond(pyexpr(f'not isinstance({var_or_prop}, dict)')) as cond:
            cond.alsoRaise("TypeError", msg=f"{var_or_prop} should be of type dict")

        # make sure all dict keys/values have the correct type
        keyspec = spec.keySpec
        assert isinstance(keyspec, ScalarTypeSpec)
        assert keyspec.originalType is str
        valuespec = spec.valueSpec
        valuevar = names.getNewName(var_or_prop, 'value', False)
        with context.withFor(PanVar(valuevar, None), pyexpr(f'{var_or_prop}.values()')) as loop:
            # TODO: also if we want to provide meaningful error messages, we really want to know
            # the key of the item that was broken and include it in the error message
            _generateConversion(loop, valuevar, valuespec, names, adv)
        return

    if isinstance(spec, DataclassTypeSpec):
        if not adv.hasDataclass(spec.class_):
            raise Exception(
                f'Cannot generate a converter for unknown dataclass {spec.class_.__name__}')

        if not names.isAssignable(var_or_prop):
            raise Exception(
                f"Can't generate a convert to build {spec.class_.__name__}"
                f" when {var_or_prop} is not assignable"
            )

        context.remark(f'try and build a {spec.class_.__name__} from {var_or_prop}')
        context.alsoAssign(PanVar(var_or_prop, None), PanCall(
            f'{spec.class_.__name__}.fromDict',
            pyexpr(var_or_prop),
            pan(var_or_prop),
        ))
        return

    if isinstance(spec, NullTypeSpec):
        # make sure the thing is null/None
        with context.withCond(pyexpr(f'{var_or_prop} is not None')) as cond:
            cond.alsoRaise("TypeError", msg=f"{var_or_prop} must be None")
        return

    if isinstance(spec, UnionTypeSpec):
        # make a list of simple expressions that can be used to verify simple types quickly, and a
        # list of TypeSpecs for which simple expressions aren't possible
        notsimple: List[TypeSpec] = []
        simpleexprs: List[str] = []

        for vspec in spec.variants:
            nomatchexpr = _getTypeNoMatchExpr(var_or_prop, vspec)
            if nomatchexpr is None:
                notsimple.append(vspec)
            else:
                simpleexprs.append(nomatchexpr)

        # if they were all simple, we can use a single negative-if to rule out some invalid types
        if simpleexprs:
            innercontext: Statements = ConditionalBlock(pyexpr(' and '.join(simpleexprs)))
            context.also(innercontext)
        else:
            innercontext = context

        if len(notsimple):
            # make sure we can assign a new value to var_or_prop
            if var_or_prop != 'result' and not names.isAssignable(var_or_prop):
                raise Exception(f"Overwriting {var_or_prop} won't work")

            # use a nested function for flow-control ... mostly so we can use 'return' statements
            # to break out of the function early if we find a matching type
            checkervar = names.getNewName('', 'value', True)
            checkername = names.getNewName('', 'checker', False)
            innercheck = FunctionSpec(checkername, CrossAny())
            innercheck.addPositionalArg(checkervar, CrossAny())
            innercontext.also(innercheck)
            innercontext.alsoAssign(PanVar(var_or_prop, None),
                                    PanCall(checkername, PanVar(var_or_prop, None)))
            innercontext = innercheck

        for vspec in notsimple:
            innercontext.remark('add a try/except for each vspec')
            with innercontext.withTryBlock() as tryblock:
                _generateConversion(tryblock, checkervar, vspec, names, adv)
                tryblock.alsoReturn(PanVar(checkervar, None))
                with tryblock.withCatchBlock('TypeError') as catchblock:
                    catchblock.remark('ignore TypeError -contine on to next variant')
                    catchblock.also(pyexpr('pass'))
        innercontext.alsoRaise("TypeError", msg=f"{var_or_prop} did not match any variant")
        return

    raise Exception(f"TODO: generate a converter for {var_or_prop} using {spec!r}")
