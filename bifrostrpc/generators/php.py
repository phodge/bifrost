from typing import List, Literal, Tuple

from paradox.expressions import PanCall, PanProp, PanVar, pan
from paradox.generate.statements import ClassSpec, DictBuilderStatement
from paradox.interfaces import AcceptsStatements
from paradox.output import Script
from paradox.typing import (CrossAny, CrossCallable, CrossCustomType, dictof,
                            unionof)

from bifrostrpc.generators import Names
from bifrostrpc.generators.common import appendFailureModeClasses
from bifrostrpc.generators.conversion import (ConverterNotPossible,
                                              FilterNotPossible,
                                              getConverterBlock,
                                              getConverterExpr,
                                              getDataclassSpec, getFilterBlock)
from bifrostrpc.typing import Advanced, FuncSpec, _generateCrossType

HEADER = 'generated by Bifrost RPC'


T_ApiFailure = CrossCustomType(phplang='ApiFailure', phpdoc='ApiFailure')


def generateClient(
    dest: Script,
    *,
    classname: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    adv: Advanced,
    flavour: Literal['abstract'],
) -> None:
    dest.add_file_comment(HEADER)

    appendFailureModeClasses(dest)

    # make copies of all our dataclasses
    for dc in adv.getAllDataclasses():
        dest.also(getDataclassSpec(dc, adv=adv, lang='php', hoistcontext=dest))

    # generate function wrappers
    _generateWrappers(classname, funcspecs, adv=adv, flavour=flavour, context=dest)


def _generateWrappers(
    classname: str,
    funcspecs: List[Tuple[str, FuncSpec]],
    *,
    adv: Advanced,
    flavour: Literal['abstract'],
    context: AcceptsStatements,
) -> None:
    next_conv_nr = 1
    cls = context.also(ClassSpec(
        classname,
        isabstract=flavour == 'abstract',
        # TODO: we really should have a docstring for this
    ))
    # add an dispatch() function that is used for all methods
    dispatchfn = cls.createMethod(
        '_dispatch',
        unionof(T_ApiFailure, CrossAny()),
        isabstract=flavour == 'abstract',
        # TODO: would be good if we could make this a protected method
    )

    # the method that should be called
    dispatchfn.addPositionalArg('method', str)
    # a dict of params to pass to the method
    dispatchfn.addPositionalArg('params', dictof(str, CrossAny()))
    # converter will be called with the result of the method call.
    # It may modify result before returning it. It may raise a TypeError
    # if any part of result does not match the method's return type.
    dispatchfn.addPositionalArg('converter_name', CrossCallable([CrossAny()], CrossAny()))

    for name, funcspec in funcspecs:
        retspec = funcspec.getReturnSpec()

        # build a custom converter function for this method
        conv_name = f'_converter_{next_conv_nr}'
        next_conv_nr += 1
        conv = cls.createMethod(conv_name, CrossAny())
        v_result = conv.addPositionalArg('result', CrossAny())
        names = Names()

        try:
            filterblock = getFilterBlock(v_result, '$DATA', spec=retspec, names=names, lang='php')
            conv.also(filterblock)
            conv.alsoReturn(v_result)
        except FilterNotPossible:
            try:
                conv.alsoReturn(getConverterExpr(
                    v_result,
                    label='$DATA',
                    spec=retspec,
                    adv=adv,
                    lang='php',
                ))
            except ConverterNotPossible:
                v_converted = names.getSpecificName('converted', True)
                conv.also(getConverterBlock(
                    v_result,
                    v_converted,
                    label='$DATA',
                    spec=retspec,
                    names=names,
                    adv=adv,
                    lang='php',
                    hoistcontext=context,
                ))
                conv.alsoReturn(v_converted)

        rettype = unionof(T_ApiFailure, _generateCrossType(retspec, adv))
        method = cls.createMethod(name, rettype)

        for argname, spec in funcspec.getArgSpecs().items():
            method.addPositionalArg(argname, _generateCrossType(spec, adv))

        v_args = PanVar('args', dictof(str, CrossAny()))
        argnames = DictBuilderStatement.fromPanVar(v_args)
        for n in funcspec.getArgSpecs().keys():
            # TODO: dataclasses aren't automatically JSON serializable, so we need to raise an
            # error if we try to generate a client that has a dataclass argument type
            argnames.addPair(n, False)
        method.also(argnames)

        method.blank()
        method.remark(
            'include [__dataclass__] in returned values so that we can rebuild dataclasses',
        )
        method.alsoAssign(v_args["__showdataclass__"], True)

        method.alsoReturn(PanCall(
            PanProp('_dispatch', CrossAny(), None),
            pan(name),
            v_args,
            pan(conv_name),
        ))
